

UFO (Useful Features Only) Logger
-----------
THIS PROJECT IS UNDER DEVELOPMENT AND SHOULDN'T BE CONSIDERED PRODUCTION-READY NOW.

Another feature reduced asynchronous data logger. Sponsored by my employer **Diadrom AB.**

We just wanted an asynchronous logger that can be used from many dynamically loaded libraries without doing link-time hacks like linking static and hiding symbols and some other features.

After having maintained a slightly modified version of glog and given the fact that this is a very small project we decided that existing wheels weren't round enough.

## Design rationale ##

 - Simple.
 - Asynchronous.
 - Low latency, fast for the caller thread. [This single threaded example](https://github.com/RafaGago/ufo-log/blob/master/example/rotation.cpp) is able to enqueue 10.000.000 log messages with one parameter in around 1.27 seconds and to write them to disk in 12.8 seconds (using my five yer old AMD Phenon 965 machine under Linux with gcc 7.1). This is an average of 127ns for this specific case (trivial message, no contention).
 - No string formatting in the calling thread, the data is raw copied. No ostreams (a very ugly part of C++ for my liking).
 - One conditional call overhead for inactive severities.
 - No singleton by design, usable from dynamically loaded libraries. You provide the instace either explicitly or by using Koenig lookup.
 - Suitable for soft-realtime work. The fast-path is almost clear from heap allocations.
 - File rotation-slicing
 - Targeting g++4.7 and VS 2010
 - Boost dependencies just for parts that will eventually go to the C++ standard.

## How does it work ##

It just borrows ideas from many of the loggers out there.

When the user is to write a log message, the size is precomputed (in most cases, when the user is not deep-copying the compiler will deduce it as a constant), then the memory is reclaimed either from the fixed size free-list or the heap (configurable) and then message is serialized and passed to the worker thread queue as an intrusive linked list node.

The user thread doesn't format strings, just copies built-in type values and whole program duration C string pointers (Deep copies can be done if required too) to the message and appends data for the worker thread to be able to decode it. This is restrictive but gives other benefits too.

The messages are formatted by using printf-style strings, where the formatting string is required to be a literal (not a const char*), e.g:

log_error ("the value of i is {} and the value of j is  {}", i, j);

The function is type-safe, when "constexpr" is available, otherwise there is no way to parse the formatting string at compile time, so format errors are caught at run time.

> see this [example](https://github.com/RafaGago/ufo-log/blob/master/example/overview.cpp)

I might work in applying a little "compression" to the integer types like protobuf does (but simpler) to try to pack the messages more in case no use of the heap is allowed.

## File rotation ##

The library can rotate fixed size log files.

Using the current C++11 standard files can just be created, modified and deleted. There is no way to list a directory, so the user is required to pass at start time the list of files generated by previous runs. I may add support for boost::filesystem /std::filesystem, but just as an optional ready code, so everyone can skip this dependency.

## Initialization ##

The library isn't a singleton, so the user should provide the front-end instance.

There are two methods, one is to provide it explicitly and the other one is by accessing a global function.

If no instance is provided, the global function "get_ufo_logger_instance()" will be called without being namespace qualified, so you can use Koenig lookup/ADL.

The name of the function can be changed at compile time, by defining UFO_GET_LOGGER_INSTANCE_FUNCNAME.

Be aware that it's dangerous to have a dynamic library or executable loaded multiple times logging to the same folder and rotating files each other. Workarounds exists, you can prepend the folder name with the process name and ID, disable rotation and manage rotation externally (e.g. by using logrotate), etc.

## Weaknesses ##

 1. No C++ ostream support.
 2. Limited formatting abilities for now (to keep the serialized message compact).
 3. No way to output runtime strings/ memory regions without deep-copying them.
 
The third point is the most restrictive for my liking, it's just inherent to the asynchronous/non-blocking design, there is no guarantee about the passed data lifetime.

It's possible to artificially increment the refcount of a shared_ptr by copying it to an instance created using "placement_new" and to decrement it in the worker using the same trick, I keep this idea on hold for now.

## Using the library ##

Currently you need to compile "frontend_def.hpp" in your project or to a shared library/DLL. You can then include "ufo_log.hpp", see the example folder.

> Written with [StackEdit](https://stackedit.io/).


